# Импортируем необходимые библиотеки
from telegram import Update, ReplyKeyboardMarkup  # для работы с Telegram API и клавиатурами
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes  # для создания бота
import json  # для работы с JSON файлами (сохранение/загрузка данных)
import os  # для работы с файловой системой
import matplotlib.pyplot as plt  # для создания графиков и диаграмм
import io  # для работы с байтовыми потоками (создание изображений в памяти)


class FinanceBot:
    """
    Телеграм-бот для управления личными финансами.

    Позволяет пользователям отслеживать доходы и расходы,
    просматривать статистику и получать визуализацию данных.
    """

    def __init__(self, token: str):
        """
        Инициализирует бота с заданным токеном.

        :param token: Токен бота, полученный от BotFather
        :type token: str
        """
        # Конструктор класса, вызывается при создании объекта бота
        self.token = token  # сохраняем токен бота для авторизации в Telegram
        self.data = self.load_data()  # загружаем данные пользователей из файла

        # Создаем главную клавиатуру с кнопками
        self.kb = [
            ["Доход", "Расход"],  # первая строка кнопок
            ["Баланс", "Статистика"],  # вторая строка кнопок
            ["Категории"]  # третья строка кнопок
        ]

        # Клавиатура с категориями для расходов
        self.exp_cat = [
            ["Еда", "Транспорт", "Жилье"],  # основные категории расходов
            ["Развлечения", "Одежда", "Здоровье"],  # дополнительные категории
            ["Образование", "Прочее", "Назад"]  # специальные категории и кнопка назад
        ]

        # Клавиатура с категориями для доходов
        self.inc_cat = [
            ["Зарплата", "Бизнес", "Инвестиции"],  # основные источники доходов
            ["Подарок", "Премия", "Прочее"],  # дополнительные источники
            ["Назад"]  # кнопка возврата
        ]

    def load_data(self):
        """
        Загружает финансовые данные пользователей из JSON файла.

        :return: Словарь с данными пользователей или пустой словарь при ошибке
        :rtype: dict
        :raises json.JSONDecodeError: Если файл содержит некорректный JSON
        :raises OSError: При проблемах с доступом к файлу
        """
        try:
            # Проверяем существует ли файл с данными
            if os.path.exists("data.json"):
                # Открываем файл для чтения
                with open("data.json", "r") as f:
                    # Загружаем JSON данные и преобразуем в Python словарь
                    return json.load(f)
        except:
            # Если произошла ошибка (файл не существует или поврежден)
            pass  # просто пропускаем ошибку
        return {}  # возвращаем пустой словарь если файла нет или ошибка

    def save_data(self):
        """
        Сохраняет финансовые данные пользователей в JSON файл.

        :raises OSError: При проблемах с записью в файл
        :raises TypeError: Если данные не могут быть сериализованы в JSON
        """
        try:
            # Открываем файл для записи
            with open("data.json", "w") as f:
                # Сохраняем данные в формате JSON с отступами
                json.dump(self.data, f)
        except:
            # Если произошла ошибка при сохранении
            pass  # пропускаем ошибку

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Обработчик команды /start - начало работы с ботом.

        :param update: Объект с информацией о входящем сообщении
        :type update: telegram.Update
        :param context: Контекст выполнения, содержит дополнительные данные
        :type context: telegram.ext.ContextTypes.DEFAULT_TYPE
        """
        # Создаем клавиатуру на основе нашего шаблона
        keyboard = ReplyKeyboardMarkup(self.kb, resize_keyboard=True)
        # Отправляем приветственное сообщение с клавиатурой
        await update.message.reply_text(
            "Выберите действие:",  # текст сообщения
            reply_markup=keyboard  # прикрепляем клавиатуру
        )